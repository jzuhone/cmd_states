#!/usr/bin/env python
"""
Update the cmd_states table to reflect current load segments / timelines
in database.  This is normally run as a cron job.

Usage: update_cmd_states.py [options]::

  Options:
    -h, --help            show this help message and exit
    --dbi=DBI             Database interface (sqlite|sybase)
    --server=SERVER       DBI server (<filename>|sybase)
    --datestart=DATESTART
                          Starting date for update (default=Now-10 days)
    --mp_dir=DIR          MP directory. (default=/data/mpcrit1/mplogs)
    --loglevel=LOGLEVEL   Log level (10=debug, 20=info, 30=warnings)
"""
import sys
import os
import time
import logging

import Chandra.cmd_states as cmd_states
import Ska.DBI

def get_options():
    from optparse import OptionParser
    parser = OptionParser()
    parser.set_defaults()
    parser.add_option("--dbi",
                      default='sqlite',
                      help="Database interface (sqlite|sybase)")
    parser.add_option("--server",
                      default='db_base.db3',
                      help="DBI server (<filename>|sybase)")
    parser.add_option("--user",
                      help="sybase user, will use Ska.DBI default by default")
    parser.add_option("--database",
                      help="sybase database, will use Ska.DBI default by default")
    parser.add_option("--mp_dir",
                      default='/data/mpcrit1/mplogs',
                      help="MP load directory")
    parser.add_option("--datestart",
                      help="Starting date for update (default=Now-10 days)")
    parser.add_option("--loglevel",
                      type='int',
                      default=20,
                      help='Log level (10=debug, 20=info, 30=warnings)')
    
    (opt, args) = parser.parse_args()
    return (opt, args)

def main():
    opt, args = get_options()

    # Configure logging to emit msgs to stdout
    logging.basicConfig(level=opt.loglevel,
                        format='%(message)s',
                        stream=sys.stdout)

    logging.info('Running {0} at {1}'.format(os.path.basename(sys.argv[0]), time.ctime()))
    logging.debug('Connecting to db: dbi=%s server=%s' % (opt.dbi, opt.server))
    try:
        db = Ska.DBI.DBI(dbi=opt.dbi, server=opt.server, user=opt.user,
                         database=opt.database, verbose=False)
    except Exception, msg:
        logging.error('ERROR: failed to connect to {0}:{1} server: {2}'.format(opt.dbi, opt.server, msg))
        sys.exit(0)

    # Get initial state containing the specified datestart
    logging.debug('Getting initial state0')
    state0 = cmd_states.get_state0(date=opt.datestart, db=db)
    logging.debug('Initial state0: datestart=%s datestop=%s obsid=%d' %
                 (state0['datestart'], state0['datestop'], state0['obsid']))

    # Sync up datestart to state0 and get timeline load segments including
    # state0 and beyond.
    datestart = state0['datestart']
    logging.debug('Getting timeline_loads after %s' % datestart)
    timeline_loads = db.fetchall("""SELECT * from timeline_loads
                                    WHERE datestop > '%s'""" % datestart)
    logging.debug('Found %s timeline_loads' % len(timeline_loads))

    # Get cmds since datestart.  If needed add cmds to database
    logging.debug('Getting cmds after %s' % datestart)
    cmds = cmd_states.get_cmds(datestart, db=db, update_db=True,
                               timeline_loads=timeline_loads, mp_dir=opt.mp_dir)
    logging.debug('Found %s cmds after %s' % (len(cmds), datestart))

    # Get the states generated by cmds starting from state0
    logging.debug('Generating cmd_states after %s' % datestart)
    states = cmd_states.get_states(state0, cmds)
    logging.debug('Found %s states after %s' % (len(states), datestart))

    # Update cmd_states in database
    logging.debug('Updating database cmd_states table')
    cmd_states.update_states_db(states, db)

if __name__ == '__main__':
    main()
