#!/usr/bin/env python

import sys
import logging

import cmd_states
import Ska.DBI

def get_options():
    from optparse import OptionParser
    parser = OptionParser()
    parser.set_defaults()
    parser.add_option("--dbi",
                      default='sqlite',
                      help="Database interface (sqlite|sybase)")
    parser.add_option("--server",
                      default='test.db3',
                      help="DBI server (<filename>|sybase)")
    parser.add_option("--datestart",
                      help="Starting date for update (default=Now-10 days)")
    parser.add_option("--loglevel",
                      type='int',
                      default=10,
                      help='Log level (10=debug, 20=info, 30=warnings)')
    
    (opt, args) = parser.parse_args()
    return (opt, args)

opt, args = get_options()

# Configure logging to emit msgs to stdout
logging.basicConfig(level=opt.loglevel,
                    format='%(message)s',
                    stream=sys.stdout)

logging.info('Connecting to db: dbi=%s server=%s' % (opt.dbi, opt.server))
db = Ska.DBI.DBI(dbi=opt.dbi, server=opt.server, verbose=False)

# Get initial state containing the specified datestart
logging.info('Getting initial state0')
state0 = cmd_states.get_state0(date=opt.datestart, db=db)
logging.info('Initial state0: datestart=%s datestop=%s obsid=%d' %
             (state0['datestart'], state0['datestop'], state0['obsid']))

# Sync up datestart to state0 and get timeline load segments including
# state0 and beyond.
datestart = state0['datestart']
logging.info('Getting timeline_loads after %s' % datestart)
timeline_loads = db.fetchall("""SELECT * from timeline_loads
                                WHERE datestop > '%s'""" % datestart)
logging.info('Found %s timeline_loads' % len(timeline_loads))

# Get cmds since datestart.  If needed add cmds to database
logging.info('Getting cmds after %s' % datestart)
cmds = cmd_states.get_cmds(datestart, db=db, update_db=True, timeline_loads=timeline_loads)
logging.info('Found %s cmds after %s' % (len(cmds), datestart))

# Get the states generated by cmds starting from state0
logging.info('Generating cmd_states after %s' % datestart)
states = cmd_states.get_states(state0, cmds)
logging.info('Found %s states after %s' % (len(states), datestart))

# Update cmd_states in database
logging.info('Updating database cmd_states table')
cmd_states.update_states_db(states, db)
